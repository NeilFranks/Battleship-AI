from collections import namedtuple
import random
import numpy as np

DEFAULT_GRID_SIZE = 10
DEFAULT_SHIPS = {5:1, 4:1, 3:2, 2:1}

#observation encoding
UNKNOWN = 0
MISS = 1
HIT = 2
SUNK = 3

ENCODING = {UNKNOWN: ' ', MISS: 'o', HIT: 'x', SUNK: '#'}


def pick_random_valid_adjacent_action(observation, row, col):
    """Returns a 2-D numpy array where each for contains the coords of a square
    adjacent to observation[row, col] and whose value is UNKNOWN.
    """
    rows, cols = observation.shape
    adj_squares = get_adjacent_squares(row, col, rows, cols)
    valid_adj = np.array([(r, c) for r,c in adj_squares if observation[r,c] == UNKNOWN], dtype=np.int32)
    assert len(valid_adj) > 0, 'Error: no valid actions adjacent to row:{} col:{}'.format(row, col)
    return random.choice(valid_adj)

def get_adjacent_squares(row, col, rows, cols):
    adj_squares = [(r,c) for r,c in [(row,col+1), (row,col-1), (row+1,col), (row-1,col)]]
    return [(r, c) for r,c in adj_squares if r >= 0 and r < rows and c >= 0 and c < cols]

def possible_hit_count(observation, ships, row, col):
    """Counts the number of ways one of the remaining ships could fit in the square.
    """
    rows, cols = observation.shape
    possible_hits = 0
    for ship_len, ship_count in ships.items():
        count = 0
        for offset in range(1, ship_len+1):
            #check if horizontally in bounds
            left = col - ship_len + offset
            right = col + offset - 1
            if left >= 0 and right < cols:
                # check location is valid ship location (no misses or sunk ships)
                possible_ship = observation[row, left:right+1]
                if MISS not in possible_ship and SUNK not in possible_ship:
                    count += 1
            #check if vertically in bounds
            up = row - ship_len + offset
            down = row + offset - 1
            if up >= 0 and down < rows:
                possible_ship = observation[up:down+1, col]
                if MISS not in possible_ship and SUNK not in possible_ship:
                    count += 1
        count *= ship_count
        possible_hits += count
    return possible_hits

def find_UNKNOWN_sequences_where_ship_can_lie(obs, ship_length):
    rows = len(obs)
    cols = len(obs[0])

    sequences = []

    # find horizontal sequences
    for i in range(rows):
        for j in range(cols-ship_length+1):
            if all(val in [UNKNOWN] for val in obs[i, j:j+ship_length]):
                sequences.append([(i, cell_j) for cell_j in range(j, j+ship_length)])


    # find vertical sequences
    for j in range(cols):
        for i in range(rows-ship_length+1):
            if all(val in [UNKNOWN] for val in obs[i:i+ship_length, j]):
                sequences.append([(cell_i, j) for cell_i in range(i, i+ship_length)])

    return sequences


def find_sequences_where_ship_covers_hit(obs, ship_length, hit_coords):
    row = hit_coords[0]
    col = hit_coords[1]
    rows = len(obs)
    cols = len(obs[0])

    sequences = []

    # find horizontal sequences
    i = row
    for j in range(col+1-ship_length, col+1):
        if j >= 0 and j+ship_length <= cols:
            if all(val in [UNKNOWN, HIT] for val in obs[i, j:j+ship_length]):
                sequences.append([(i, cell_j) for cell_j in range(j, j+ship_length)])

    # find vertical sequences
    j = col
    for i in range(row+1-ship_length, row+1):
        if i >= 0 and i+ship_length <= rows:
            if all(val in [UNKNOWN, HIT] for val in obs[i:i+ship_length, j]):
                sequences.append([(cell_i, j) for cell_i in range(i, i+ship_length)])

    return sequences

def generate_particle_recursive(obs, ships: dict, depth=0):
    """
    SETUP
    """
    # put ships in random order
    ship_list = []
    for ship in ships.keys():
        for _ in range(ships[ship]):
            ship_list.append(ship)
    random.shuffle(ship_list)

    # find all hits; put them in random order
    hit_list = []
    for i in range(len(obs)):
        for j in range(len(obs[i])):
            if obs[i][j] == HIT:
                hit_list.append((i, j))
    random.shuffle(hit_list)

    """
    Place a ship and recurse until either it works, or you determine it's impossible
    """
    ship_index = 0
    hit_index = 0
    sub_particle = None  # This is a particle which will be generated by a recursive call
    temp_obs = obs.copy()  # keep a temp observation
    while type(sub_particle)==type(None) or HIT in temp_obs:
        # If we've checked every ship and still no luck, this must be impossible; there is no particle to return
        if ship_index >= len(ship_list):
            return None

        # select a ship
        ship_to_place = ship_list[ship_index]

        if hit_list:
            # select a hit
            hit_to_cover = hit_list[hit_index]

            # find all sequences of cells which the ship could lie on which would cover the hit
            sequences = find_sequences_where_ship_covers_hit(obs=obs, ship_length=ship_to_place, hit_coords=hit_to_cover)
        else:
            # find all sequences of cells which the ship could lie on which are all UNKNOWN cells
            sequences = find_UNKNOWN_sequences_where_ship_can_lie(obs=obs, ship_length=ship_to_place)

        # only continue if there is at least one sequence
        if sequences:
            random.shuffle(sequences)

            sequence_index = 0
            while sequence_index < len(sequences) and type(sub_particle)==type(None):
                
                particle = np.zeros(obs.shape, dtype=np.int32)  # keep track of your particle
                temp_obs = obs.copy()  # keep a temp observation
                temp_ships = ships.copy()  # keep temp copy of ships

                # place the ship on a selected sequence and see if it works
                selected_sequence = sequences[sequence_index]
                for cell in selected_sequence:
                    # update our observation
                    temp_obs[cell] = SUNK

                    # update our particle
                    particle[cell] = SUNK

                # we have placed this ship!
                temp_ships[ship_to_place] -= 1

                if all(val == 0 for val in temp_ships.values()):
                    # No ships left, you're good!
                    sub_particle = np.zeros(obs.shape, dtype=np.int32) 
                else:
                    # recurse; place the remaining ships!
                    sub_particle = generate_particle_recursive(temp_obs, temp_ships, depth=depth+1)

                # If the subparticle is not None, congrats, it worked!
                sequence_index += 1

        # If we havent solved it, we'll need to check the next hit
        hit_index += 1

        # If true, we checked every possible hit for this boat; This boat must not lie on a hit. Try the next boat!
        if hit_index >= len(hit_list):
            hit_index = 0
            ship_index += 1

        if type(sub_particle)!=type(None):
            # update temp_obs to reflect the other ships
            for i in range(len(sub_particle)):
                for j in range(len(sub_particle[i])):
                    if sub_particle[i][j] != 0:
                        temp_obs[i][j] = 3

            particle = particle + sub_particle

    return particle


def generate_particle(obs, ships: dict):
    '''
    observation: What the agent knows about the state
    ships: a dict; key is the length of a ship, the value is how many ships there are of that length
    '''
    board_with_only_SUNKS = np.zeros(obs.shape, dtype=np.int32)
    for i in range(len(obs)):
        for j in range(len(obs[i])):
            if obs[i][j] == SUNK:
                board_with_only_SUNKS[i][j] = SUNK

    return board_with_only_SUNKS+generate_particle_recursive(obs, ships)


def show_ships(state):
    rows = len(state)
    cols = len(state[0])

    max_digits = len(str(state.max()))

    print('\nShip placement:')
    line = '    ' + ((' '*max_digits)+' ').join('{:2}'.format(k) for k in range(cols))
    print(line)
    horizontal_line = '-' * ((3+max_digits) * cols - 1)
    print('   +' + horizontal_line + '+')
    for i in range(rows):
        line = '{:2} |'.format(i)
        for j in range(cols):
            v = str(state[i][j])
            line += ' ' + ' '*(max_digits-len(v)) + v + ' |'
        print(line)
        if i < rows -1:
            print('   |' + horizontal_line + '|')
    print('   +' + horizontal_line + '+')


if __name__ == '__main__':
    obs = np.zeros((10,10), dtype=np.int32)

    ships = DEFAULT_SHIPS
    print(possible_hit_count(obs, ships, 5, 5))
